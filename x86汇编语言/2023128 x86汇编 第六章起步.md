## 2023/12/8 x86汇编 第六章起步

### 一.关于显存

​	显卡用来控制显示器上面的像素点，显卡可以看做是只负责图像显示的CPU，同时为了存储每个像素应该显示的值，显卡具有自己存储器（Video RAM，VRAM），简称显存，要显示的内容都预先写入显存。

​	由于显示的内容是由CPU传递过去的，所以为了防止CPU访问写入显存的时候还需要和显卡进行交互，工程师们**将显存直接映射到了内存上，处理器可以直接访问内存的地址空间来写入显存数据**

​	8086中：

- 0xF0000-0xFFFFF属于ROM-BIOS
- 0x00000-0x9FFFF属于常规内存，由内存条提供
- 中间的320KB的内容中由外围设备提供，在这些外围设备中就有显存，0xB8000-0xBFFFF这段物理地址空间就是留给显存的。

<img src="https://typora-oldoldcoder.oss-cn-hangzhou.aliyuncs.com/img/image-20231208103649307.png" alt="image-20231208103649307" style="zoom:50%;" />

### 二.汇编代码的基本格式

~~~assembly
section .data
;数据定义
section .text
	global _start
_start:
; 代码放在这里
~~~

在汇编语言中 **global** 是一个关键字，用于声明一个标识符为全局标识符，全局标识符表示该标志符可以被其他的模块或者文件引用，具有全局作用域。使用global 关键字将标识符声明为全局，可以是的其他部分的代码能够访问或者使用这标识符。

另外函数都以_开始是一种命名约定，在汇编语言中，使用 _ 开头的标识符代表全局标识符。

不同编译器对于结构的定义不同，在masm中使用.code来进行定义代码段，而在nasm中使用.text来定义

### 三.lodsb和stosb两个指令

- `lodsb` 指令是 Load String Byte 的缩写。它的作用是从指定的内存地址（由 `si` 寄存器指定）加载一个字节到累加器 `al` 中，并且递增 `si` 的值，使其指向下一个字节。这个指令通常用于处理字符串。

  在这个例子中：

  ```
  assemblyCopy code
  lodsb   ; 加载si指向的字符到al，并递增si
  ```

  这条指令加载 `si` 指向的字符串的当前字符到累加器 `al` 中，然后递增 `si`，使其指向下一个字符。

- `stosb` 指令是 Store String Byte 的缩写。它的作用是将累加器 `al` 中的值存储到指定的内存地址（由 `es:di` 寄存器指定），并且递增 `di` 的值，使其指向下一个字节。这个指令通常用于将数据写入字符串。

  在这个例子中：

  ```
  assemblyCopy code
  stosb   ; 将al的值存储到es:di指向的内存位置，并递增di
  ```

  这条指令将累加器 `al` 中的字符写入到由 `es:di` 指定的内存地址，然后递增 `di`，使其指向下一个位置，准备存储下一个字符。

这两个指令结合使用可以在字符串间复制数据，比如从源字符串复制到目标字符串，或者在字符串中插入新的字符等等。

### 四.关于第六章中使用VHD虚拟硬盘在其中写入内容可以进行裸机编程的疑问

#### 1.Virtual box这种内容不会模拟CPU，所以所有的代码仍然是在我宿主机的架构上执行对吗

​	是的，只有QEMU这类可以模拟CPU去执行不同架构的代码，所以实际在使用Virtual box的时候，你仍然是在自己的机器的CPU上执行

### 2.为什么我在目前的机器上写的汇编运行的时候不能直接修改我本地x64机器的bios，或者MBR去导致机器启动错误

- 用户态和内核态，二者允许访问的内存空间大小不同
- 内存保护机制，现代操作系统和处理器通常会实施内存保护机制，包括分页和段机制。

### 五.Bochs的一些使用方法

- r 显示通用寄存器内容
- sreg 显示段寄存器内容
- s 单步执行
- b addr 打断电地址
- c 持续执行到断电
- xp /a addr 显示a个双字，在地址addr处

![image-20231208162540122](https://typora-oldoldcoder.oss-cn-hangzhou.aliyuncs.com/img/image-20231208162540122.png)

不知道什么狗屎原因，只要通过SI进行寻址就会出现问题，导致一直的一直无法显示字符串在裸机上面

